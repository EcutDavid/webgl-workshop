<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WebGL workshop</title>
  <style>
  html, body {
    height: 100%;
    background: #000;
    text-align: center;
  }

  p, h1 {
    color: #fff;
    font-weight: bold;
  }
  </style>
</head>
<body>
  <h1>WebGL workshop</h1>
  <p>More content will be added</p>
  <canvas width="600" height="600"></canvas>
  <p>David Guan</p>
  <p>davidguandev@gmail.com</p>

  <script>
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var gl = document.querySelector('canvas').getContext('webgl');
    gl.clearColor(0, 0, 0, 1);
    var canvasWidth = 600;
    var canvasHeight = 600;
    var canvasDepth = 600;

    var vertexShaderSource = '\n  attribute vec4 position;\n  uniform mat4 transform;\n  \n  void main() {\n    gl_Position = transform * position;\n  }\n';

    var fragmentShaderSource = '\n  precision mediump float;\n  uniform vec4 color;\n \n  void main() {\n    gl_FragColor = color;\n  }\n';

    function createShader(gl, type, shaderSource) {
      var shader = gl.createShader(type);
      gl.shaderSource(shader, shaderSource);
      gl.compileShader(shader);

      var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
      if (!success) {
        console.warn(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
      }

      return shader;
    }

    var M4 = function () {
      function M4() {
        _classCallCheck(this, M4);
      }

      _createClass(M4, null, [{
        key: 'projection',
        value: function projection(width, height, depth) {
          // Note: This matrix flips the Y axis so 0 is at the top.
          return [2 / width, 0, 0, 0, 0, -2 / height, 0, 0, 0, 0, 2 / depth, 0, -1, 1, 0, 1];
        }
      }, {
        key: 'multiply',
        value: function multiply(matrixA, matrixB) {
          var matrixALength = Math.sqrt(matrixA.length);
          var matrixBLength = Math.sqrt(matrixB.length);
          if (matrixALength !== matrixBLength) {
            throw new Error('Length matrices should be same');
          }
          var length = matrixALength;
          var result = [];
          for (var i = 0; i < length; i++) {
            for (var j = 0; j < length; j++) {
              var value = 0;
              for (var k = 0; k < length; k++) {
                value += matrixB[i * length + k] * matrixA[k * length + j];
              }
              result[i * length + j] = value;
            }
          }
          return result;
        }
      }, {
        key: 'translation',
        value: function translation(tx, ty, tz) {
          return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1];
        }
      }, {
        key: 'xRotation',
        value: function xRotation(angleInRadians) {
          var c = Math.cos(angleInRadians);
          var s = Math.sin(angleInRadians);

          return [1, 0, 0, 0, 0, c, s, 0, 0, -s, c, 0, 0, 0, 0, 1];
        }
      }, {
        key: 'yRotation',
        value: function yRotation(angleInRadians) {
          var c = Math.cos(angleInRadians);
          var s = Math.sin(angleInRadians);

          return [c, 0, -s, 0, 0, 1, 0, 0, s, 0, c, 0, 0, 0, 0, 1];
        }
      }, {
        key: 'zRotation',
        value: function zRotation(angleInRadians) {
          var c = Math.cos(angleInRadians);
          var s = Math.sin(angleInRadians);

          return [c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        }
      }, {
        key: 'scaling',
        value: function scaling(sx, sy, sz) {
          return [sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1];
        }
      }, {
        key: 'translate',
        value: function translate(m, tx, ty, tz) {
          return M4.multiply(m, M4.translation(tx, ty, tz));
        }
      }, {
        key: 'xRotate',
        value: function xRotate(m, angleInRadians) {
          return M4.multiply(m, M4.xRotation(angleInRadians));
        }
      }, {
        key: 'yRotate',
        value: function yRotate(m, angleInRadians) {
          return M4.multiply(m, M4.yRotation(angleInRadians));
        }
      }, {
        key: 'zRotate',
        value: function zRotate(m, angleInRadians) {
          return M4.multiply(m, M4.zRotation(angleInRadians));
        }
      }, {
        key: 'scale',
        value: function scale(m, sx, sy, sz) {
          return M4.multiply(m, M4.scaling(sx, sy, sz));
        }
      }]);

      return M4;
    }();

    var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

    function createProgram(gl, vertexShader, fragmentShader) {
      var program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      var success = gl.getProgramParameter(program, gl.LINK_STATUS);
      if (!success) {
        console.log(gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
      }

      return program;
    }

    var program = createProgram(gl, vertexShader, fragmentShader);
    gl.useProgram(program);

    var positionAttributeLocation = gl.getAttribLocation(program, 'position');
    var transformUniformLocation = gl.getUniformLocation(program, 'transform');
    var transformMatrix = M4.projection(canvasWidth, canvasHeight, canvasDepth);
    transformMatrix = M4.translate(transformMatrix, 240, 150, 0);
    gl.uniformMatrix4fv(transformUniformLocation, false, transformMatrix);
    var colorUniformLocation = gl.getUniformLocation(program, 'color');
    gl.uniform4fv(colorUniformLocation, [0.5, 0.5, 1, 1]);

    var positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

    function translateGeo(geo, tansX) {
      geo.forEach(function (d, i) {
        if (i % 3 === 0) {
          geo[i] = d + tansX;
        }
      });
    }

    function draw() {
      var elePlaneGeo = [0, 100, 0, 100, 100, 0, 0, 100, 100, 100, 100, 100, 100, 100, 0, 0, 100, 100, 0, 100, 0, 50, 50, 50, 0, 100, 100, 100, 100, 0, 50, 50, 50, 0, 100, 100, 100, 100, 0, 50, 50, 50, 100, 100, 100, 0, 100, 100, 50, 50, 50, 100, 100, 100];
      translateGeo(elePlaneGeo, 140);

      var eleLineGeo = [0, 100, 0, 100, 100, 0, 0, 100, 0, 0, 100, 100, 100, 100, 100, 0, 100, 100, 100, 100, 100, 100, 100, 0, 50, 50, 50, 0, 100, 100, 50, 50, 50, 100, 100, 0, 50, 50, 50, 0, 100, 0, 50, 50, 50, 100, 100, 100];
      translateGeo(eleLineGeo, 140);

      var cubePlaneGeo = [0, 0, 0, 100, 0, 0, 0, 0, 100, 100, 0, 100, 100, 0, 0, 0, 0, 100, 0, 100, 0, 100, 100, 0, 0, 100, 100, 100, 100, 100, 100, 100, 0, 0, 100, 100, 0, 0, 0, 0, 0, 100, 0, 100, 0, 0, 100, 100, 0, 0, 100, 0, 100, 0, 100, 0, 0, 100, 0, 100, 100, 100, 0, 100, 100, 100, 100, 0, 100, 100, 100, 0, 0, 0, 0, 100, 0, 0, 0, 100, 0, 100, 100, 0, 100, 0, 0, 0, 100, 0, 0, 0, 100, 100, 0, 100, 0, 100, 100, 100, 100, 100, 100, 0, 100, 0, 100, 100];
      var cubeLineGeo = [0, 0, 0, 100, 0, 0, 0, 0, 0, 0, 0, 100, 100, 0, 100, 100, 0, 0, 100, 0, 100, 0, 0, 100, 0, 100, 0, 100, 100, 0, 0, 100, 0, 0, 100, 100, 100, 100, 100, 100, 100, 0, 100, 100, 100, 0, 100, 100, 0, 0, 0, 0, 100, 0, 100, 0, 0, 100, 100, 0, 0, 0, 100, 0, 100, 100, 100, 0, 100, 100, 100, 100];

      gl.enableVertexAttribArray(positionAttributeLocation);
      gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);

      gl.uniform4fv(colorUniformLocation, [1, 1, 1, 1]);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(elePlaneGeo), gl.STATIC_DRAW);
      gl.drawArrays(gl.TRIANGLES, 0, elePlaneGeo.length / 3);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubePlaneGeo), gl.STATIC_DRAW);
      gl.drawArrays(gl.TRIANGLES, 0, cubePlaneGeo.length / 3);

      gl.uniform4fv(colorUniformLocation, [0.5, 0.5, 0.5, 1]);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(eleLineGeo), gl.STATIC_DRAW);
      gl.drawArrays(gl.LINES, 0, eleLineGeo.length / 3);

      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeLineGeo), gl.STATIC_DRAW);
      gl.drawArrays(gl.LINES, 0, cubeLineGeo.length / 3);
    }

    var counter = 0;
    setInterval(function () {
      gl.clear(gl.COLOR_BUFFER_BIT);
      draw();
      transformMatrix = M4.yRotate(transformMatrix, Math.PI / 60);
      transformMatrix = M4.zRotate(transformMatrix, Math.PI / 60);
      transformMatrix = M4.xRotate(transformMatrix, Math.PI / 60);
      gl.uniformMatrix4fv(transformUniformLocation, false, transformMatrix);
    }, 50);
  </script>
</body>
</html>
